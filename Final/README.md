შექმენით პირველი სისტემა:  ვებ სერვისი A, რომელშიც იქნებიან მომხმარებლები (war ფაილი) და  შესაძლებელი იქნება მათთვის ბალანსის შევსება სხვადასხვა აგენტების მიერ.  სისტემაში უნდა იყოს შემდეგი ცხრილები:

1. users - შენახული უნდა იყოს  მომხარებლის id (integer primary key), სახელი, გვარი, პირადი ნომერი  (სტრიქონულ ფორმატში, unique) და ბალანსი ლარებში decimal ფორმატში  მეასედებამდე სიზუსტით, მაგალითად, 10.25 არის 10 ლარი და 25 თეთრი.
2.  agents - ამ ცხრილში შენახული უნდა იყოს ბალანსის შევსების ვებ სერვისის  გამომძახებელი აგენტები. ველები: id (integer primary key), name  (ინფორმაციული ველი), password.
3. agent_access - ამ ცხრილში უნდა იყოს  შენახული აგენტების დაშვებული IP მისამართები. ველები: row_id (integer  primary key identity), allowed_ip და agent_id (გარე გასაღები agents  ცხრილთან, კავშირი ბევრი ერთთან).
4. transactions - შენახული უნდა იყოს  ტრანზაქციების ისტორია: system_transaction_id (bigint primary key  identity), agent_id (გარე გასაღები agents ცხრილთან, კავშირი ბევრი  ერთთან), agent_transaction_id (სტრიქონული, უნიკალური უნდა იყოს agent_id  ველთან ერთად), user_id (გარე გასაღები users ცხრილთან, კავშირი ბევრი  ერთთან), amount ტრანზაქციის თანხა (decimal ფორმატში მეასედებამდე  სიზუსტით), transaction_date (ჩანაწერის გაკეთების დრო, TIMESTAMP). ამ  ცხრილში ვინახავთ მხოლოდ წარმატებულ ტრანზაქციებს, შესაბამისად ტრანზაქციის  სტატუსის ველი არ გვაქვს.

დაწერეთ soap ვებ სერვისი (პარამეტრების სტილი WRAPPED ან BARE, არჩევანი თავისუფალია) შემდეგი ვებ მეთოდებით:
თითოეულ  მეთოდს გადაეცემა ორი ჰედერი: agent - სადაც უნდა ჩაიწეროს აგენტის id და  მეორე ჰედერი pass - აგენტის პაროლი base64 ფორმატში. თუ სისტემაში აგენტი  ვერ მოიძებნა ან პაროლი არასწორადაა გადმოცემული, ვებ მეთოდი უნდა გავიდეს  AgentAuthFailed FAULT-ზე. თუ აგენტის id მოიძებნა, პაროლიც სწორია, მაგრამ  ip არაა დაშვებული, ვებ მეთოდი უნდა გავიდეს AgentAccessDenied FAULT-ზე.

1.  check - გადაეცემა user_id და ამოწმებს მომხმარებელს სისტემაში და თუ  იპოვა აბრუნებს FullName (ინიციალები: სახელის პირველი ასო, წერტილი,  გამოტოვება, გვარის პირველი ასო და წერტილი ფორმატში. მაგალითად, Giorgi  Katsadze უნდა დაბრუნდეს G. K.) და Balance ველებს. თუ ვერ იპოვა, გადის  UserNotFound FAULT-ზე, ხოლო სხვა დანარჩენ შემთხვევაში InternelError-ის  FAULT-ზე.
2. pay - ახდენს მომხმარებლისთვის ბალანსის შევსებას.  გადაეცემა transaction_id (აგენტის), user_id, amount და ახდენს  მომხმარებლის ბალანსის შევსებას amount თანხით და წარმატების შემთხვევაში  აბრუნებს ავტომატურად დაგენერირებული system_transaction_id ველს.  წარმატებულად ითვლება გადახდა, თუ users ცხრილში ბალანსი წარმატებულად  გაიზარდა და transactions ცხრილში ჩანაწერი წარმატებით გაკეთდა. ეს ორივე  ოპერაცია ერთად უნდა შესრულდეს, რომ წარმატებულად ჩაითვალოს ტრანზაქცია. თუ  აგენტი გაიმეორებს ზუსტად იგივე request-ს, ანუ transaction_id (აგენტის),  user_id, amount ამ სამ ველს ზუსტად იმავეს გამოუშვებს, რაც წინაზე ჰქონდა  გამოგზავნილი, სისტემამ ისევ პასუხად უნდა დაუბრუნოს  system_transaction_id ველი (ბუნებრვია ახალ ტრანზაქციად ვერ გაფორმდება და  ბალანსის ცვლილება აქ არ უნდა მოხდეს არავითარ შემთხვევაში). თუ აგენტმა  თავისი transaction_id-ის ჭრილში შეცვალა user_id ან amount და ისე გააკეთა  retry, მაშინ უნდა დაუბრუნდეს DuplicateFault და რა თქმა უნდა, არც ამ  დროს უნდა შეიცვალოს ბალანსი. ასევე თუ არასწორი user_id გადმოსცა უნდა  დაუბრუნდეს UserNotFound FAULT, ხოლო თუ 0-ზე ნაკლებია ან ტოლი თანხა  გადმოსცა, AmountNotPositive FAULT. სხვა დანარჩენ შემთხვევაში  InternelError-ის FAULT დაბრუნდეს.
3. status - გადაეცემა  transaction_id (აგენტის) და ჩანაწერს ეძებს transactions ცხრილში. თუ  იპოვა, აბრუნებს შესაბამის system_transaction_id-ს, ხოლო თუ ვერ იპოვა  აბრუნებს TransactionNotFound FAULT-ს. დანარჩენ შემთხვევაში  InternelError-ის FAULT დაბრუნდეს.

შექმენით მეორე სისტემა: ვებ  სერვისი B, რომელიც იქნება RESTful ვებ სერვისი და იქნება ვებ  სერვის A-ს აგენტი პროქსი (კლიენტი, war ფაილი). ვებ სერვის B-ს უნდა  ჰქონდეს კონფიგურაციული properties ფაილი (მეხსიერებაში მხოლოდ ცვლილების  შემთხვევაში ჩატვირთვის წესით), სადაც გაწერილი იქნება ერთი კონკრეტული  აგენტის id და პაროლი და ამ აგენტით ემუშავება ვებ სერვის A-ს. ასევე  კონფიგურაციულ ფაილში გაწერილი უნდა იყოს ვებ სერვის A-ს endpoint URL და  ტაიმაუტი წამებში (connect/read ტაიმაუტზე ორივეზე ეს რიცხვი დაყენდეს).

ვებ სერვის B-ს უნდა ჰქონდეს შემდეგი მეთოდები:

1.  getUser - GET-ის path param-ით გადაეცემა user_id და იძახებს ვებ სერვის  A-ს check-ს. წარამტების შემთხვევაში თავადაც აბრუნებს FullName და Balance  (JSON ფორმატში) და http 200 კოდს. UserNotFound-ის FAULT თუ მიიღო,  აბრუნებს 404 http კოდს, თუ გამოძახება გავიდა ტაიმაუტზე 408 კოდს, ხოლო  ყველა სხვა შემთხვევაში 500 http კოდს.
2. fillBalance - POST-ით JSON  ფორმატში გადაეცემა payment_id (აგენტის), user_id, amount და იძახებს ვებ  სერვის A-ს pay-ს. წარმატების შემთხვევაში აბრუნებს http 200 კოდს და  transaction_id ველს JSON ფორმატში, სადაც ეწერება ვებ სერვის A-ს  system_transaction_id ველი. UserNotFound FAULT-ზე დააბრუნოს 404 კოდი,  AmountNotPositive FAULT-ზე 400 კოდი, DuplicateFault-ზე 409 კოდი, თუ  გამოძახება გავიდა ტაიმაუტზე 408 კოდი, ხოლო სხვა შემთხვევებში 500-იანი  კოდი.
ვებ სერვისი B-ს უნდა ჰქონდეს ერთი payments ცხრილი, სადაც  შეინახავს ტრანზაქციების ისტორიას. ცხრილს უნდა ჰქონდეს ველები: payment_id  (PK, აგენტის, მონაცემის ტიპი თავისუფალია), user_id, amount,  transaction_id  (ვებ სერვის A-ს system_transaction_id, ინფორმაციული  ველი), request_date timestamp (მოთხოვნის გაგზავნის დრო), response_date  timestamp (მოთხოვნაზე პასუხის მიღების დრო), code (smallint, ის http  სტატუს კოდი, რაც დააბრუნა fillBalance მეთოდმა ბოლო მიმართვაზე), status  (smallint, დასაშვებია მხოლოდ სამი მნიშვნელობა: 0, 1 ან 2. ცხრილს უნდა  ჰქონდეს check constraint და ამოწმებდეს, რომ ამ სამი მნიშვნელობის გარდა  სხვა არაფერი ჩაიწეროს).

ტრანზაქციებს სტატუსები ენიჭებათ შემდეგი პრინციპით:
0 (საბოლოო) - ტრანზაქციამ წარმატებით ჩაიარა: ვებ სერვის A-მ დააბრუნა system_transaction_id. 
1  (არა საბოლოო) - ტრანზაქციამ წარუმატებლად ჩაიარა, მაგრამ ხელმეორედ ცდას  ექვემდებარება: ვებ სერვის A-მ დააბრუნა InternelError-ის FAULT ან ვებ  სერვის A-ს pay მეთოდის გამოძახებაზე ვებ სერვისი B გავიდა ტაიმაუტზე ან  რაიმე კავშირის შეცდომაზე.
2 (საბოლოო) - ტრანზაქციამ წარუმატებლად  ჩაიარა და ხელმეორედ ცდას არ ექვემდებარება - InternelError-ის გარდა ყველა  სხვა დანარჩენი FAULT, რაც შეილება დაბრუნდეს ვებ სერვის A-დან.

თუ ვებ  სერვის B-ს კლიეტნმა fillBalance გამოიძახა payments ცხრილში უკვე  არსებული payment_id-ით, პირველ რიგში უნდა გაკეთდეს შემოწმება payments  ცხრილში. თუ მოთხოვნაში გადმოცემული user_id ან amount არ დაემთხვა ცხრილში  არსებულს, პირდაპირ დააბრუნოს 409 დუბლირების შეცდომა. თუ ეს შემოწმება  გაიარა, შემდეგ გადავიდეს სტატუსზე. თუ სტატუსი = 1-ს, მაშინ წავიდეს ისევ  ვებ სერვის A-ს pay-ზე და მიღებული პასუხის მიხედვით დააბრუნოს პასუხი და  განაახლოს code და status ველები payments ცხრილში. თუ სტატუსი = 0 ან 2-ს,  მაშინ პასუხად დააბრუნოს code ველში ჩაწერილი რიცხვი და აღარ წავიდეს ვებ  სერვის A-ს pay-ზე.

ვებ სერვისი B-ს თავის ვებ პროექტში უნდა ჰქონდეს  PaymentsRetry quartz job, რომელიც გაეშვება ყოველ 30 წამში და ნახავს ხომ  არ აქვს payments ცხრილში რაიმე ჩანაწერი status = 1 - ით. თუ აქვს,  თითოეულისთვის მიმდერვობით გამოიძახებს ვებ სერვისი A-ს pay-ს და payments  ცხრილში code და status-ს ველს დაბრუნებული შედეგის მიხედვით განაახლებს  ისე, როგორც იქცევა fillBalance ვებ მეთოდი. quartz-ის კონფიგურაცია  შენახული უნდა იყოს ტომკეტის conf-ში xml ფორმატში.

ვებ სერვის A და  ვებ სერვის B ორივე იყენებს Derby-ს მონაცემთა ბაზას ქსელურ რეჟიმში.  ორივეს საკუთარი სხვადასხვა ბაზები აქვთ და მუშაობენ app default სქემებში.

პროექტში წარმოდგენილი უნდა გქონდეთ ცხრილების შექმნის სკრიპტები, ასევე  ვებ სერვის A-ში users, agents, agent_access ამ ცხრილების insert-ები.

ვებ  სერვის A და ვებ სერვის B ორივე deploy-ვდება ტომკეტზე. ბაზის დრაივერის  და log4j2-ის ბიბლიოთეკები pom-ში გაწერილი უნდა იყოს scope=provided, ხოლო  სხვა დანარჩენი ბიბლიოთეკები scope=compile.

ვებ სერვის A-ს და ვებ სერვის B-ს, ორივეს უნდა ჰქონდეს ზუსტი, გასაგები და ლოგიკური ლოგირება.

ვებ  სერვის A-ს კონფიგურაციაში ექნება მხოლოდ log4j2.xml, ხოლო ვებ სერვის  B-ს, log4j2 და quartz-ის xml-ები და app properties ფაილი, სადაც იქნება  ზემოთ აღწერილი კონფიგურაცია (url, timeout, agent_id, password).

ვებ სერვის A და ვებ სერვის B ორივე უკავშირდება მონაცემთა ბაზას jndi datasource-ით და apache-ის dbcp2 connection pooling-ით.

ვებ სერვის A-ს (Soap UI) და ვებ სერვის B-ს (Postman) ტესტირების სქრინები დავალებაში უნდა იყოს წარმოდგენილი.

შექმენით  მესამე სისტემა: ვებ კლიენტ C, რომელიც იქნება ვებ სერვის B-ს  კლიენტი (jar ფაილი) ჯავას ახალი http client-ით დაწერილი. აქ ლოგირება  საჭირო არაა, მაგრამ ვებ სერვის B-ს url და ტაიმაუტი უნდა ჰქონდეს  კონფიგურაციულ ფაილში გაწერილი. უნდა ეშვებოდეს მარტივად java -jar-ით.

 აქ უნდა გაიტესტოს რამდენიმე შემთხვევა, რომ ისე მუშაობს, როგორიცაა მოლოდინი:
 
1. getUser-ს ვიძახებთ არსებული user_id-ით და წარმატებით გვიბრუნდება მომხმარებლი FullName და Balance.
2. getUser-ს ვიძახებთ არ არსებული user_id-ით და გვიბრუნდება 404 http კოდი.
3.  fillBalance-ს ვიძახებთ არარსებული payment_id-ით, არსებული user_id-ით და  სწორი თანხით და გვიბრუნდება http 200 კოდი და transaction_id ველი.
4. fillBalance-ს ვიძახებთ არარსებული payment_id-ით, არ არსებული user_id-ით და გვიბრუნდება 404 http კოდი.
5. fillBalance-ს ვიძახებთ არარსებული payment_id-ით, არსებული user_id-ით და არასწორი თანხით და გვიბრუნდება 400 http კოდი.
6.  fillBalance-ს ვიძახებთ  არსებული payment_id-ით (user_id და amount-ს არ  ვცვლით), რომლის სტატუსი იყო 0 და გვიბრუნდება 200 კოდი (მოთხოვნა არ მიდის  ვებ სერვის A-მდე).
7. fillBalance-ს ვიძახებთ არსებული payment_id-ით  (user_id და amount-ს არ ვცვლით), რომლის სტატუსი იყო 1 და უნდა წავიდეს  მოთხოვნა ვებ სერვის A-ზე (სანამ job მოასწრებს) და შესაბამისი კოდი  დაბრუნდეს.
8. fillBalance-ს ვიძახებთ  არსებული payment_id-ით (user_id  და amount-ს არ ვცვლით), რომლის სტატუსი იყო 2 და payments ცხრილში  არსებული code დაბრუნდეს. მოთხოვნა არ მიდის ვებ სერვის A-მდე).
9. fillBalance-ს ვიძახებთ  არსებული payment_id-ით და user_id-ს ვცვლით და უნდა დაბრუნდეს 409 დუბლირების კოდი.
10. fillBalance-ს ვიძახებთ  არსებული payment_id-ით და amount-ს ვცვლით და უნდა დაბრუნდეს 409 დუბლირების კოდი.
