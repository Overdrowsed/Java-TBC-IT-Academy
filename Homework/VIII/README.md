## დავალება 09.06.2022

წინა დავალებებში არსებული Rectangle კლასი გადააკეთეთ ასე:

1.  Rectangle კლასს განუსაზღვრეთ ბუნებრივად შედარების წესი: თუ პირველი  მართკუთხედის სიგრძე უდრის მეორე მარკთუხედის სიგრძეს და ასევე პირველი  მართკუთხედის სიგანე უდრის მეორე მარკთუხედის სიგანეს, მაშინ ჩაითვალოს  მართკუთხედები ტოლად. სხვა შემთხვევაში მართკუთხედები განსხვავებულია. რაც  შეეხება მეტობა-ნაკლებობას, მეტად ჩაითვალოს ის მართკუთხედი, რომლის  ფართობიც უფრო მეტია.
Rectangle კლასისთვის ასევე შექმენით სხვანაირი შედარების მექანიზმებიც. კერძოდ:

2.  პირველი და მეორე მართკუთხედი შედარდეს მხოლოდ ფართობებით: ანუ თუ  ფართობები ტოლია, მართკუთხედებიც ჩაითვალოს ტოლად. თუ პირველის ფართობი  მეტია, მეტად ჩაითვალოს პირველი მართკუხედი, თუ მეორის ფართობია მეტი -  მეტად ჩაითვალოს მეორე მართკუთხედი.

3. მე-2 პუნქტის ანალოგიური  მექანიზმი გააკეთეთ პერიმეტრზე ოღონდ ისე, რომ ამ მექანიზმით სორტირებამ  მართკუთხედების სიმრავლე პერიმეტრის კლებადობით დაალაგოს.

4. შექმენით  მართკუთხედების მასივი და დაბეჭდეთ ციკლით. შემდეგ დაასორტირეთ მასივი  მართკუთხედების შედარების ბუნბრივი წესით (აღწერილია პირველ პუნქტში) და  ასევე დაბეჭდეთ. მე-2 პუნქტში აღწერილი მექანიზმით და ერთი გამოძახებით  მასივში იპოვეთ მართკუთხედი რომლის ფართობია 20. შემდეგ მასივი დაასორტირეთ  მე-2 პუნქტში აღწერილი მექანიზმით და ისევ დაბეჭდეთ. მასივზე იტერაცია  ჩაატარეთ ჩვეულებრივი for-ით მასივი სიგრძის შემოწმებითა და ინდექსებზე  გავლით.

5. შექმენით მართკუთხედების ArrayList და დაასორტირეთ  პერიმეტრით კლებადობით. ArrayList-ში ერთი გამოძახებით იპოვეთ ისეთი  მართკუთხედი, რომლის პერიმეტრია 15. ასევე ArrayList-ში ერთი გამოძახებით  იპოვეთ ზუსტად ისეთი მართკუთხედი, რომლის გვერდის სიგრძე უდრის 3-ს, ხოლო  სიგანე 4-ს. ArrayList-ში შენახული გქონდეთ ისეთი მართკუთხედებიც, რომლებიც  ბუნებრივად ერთმანეთის ტოლია (პირველი პუნქტი). ArrayList-ზე იტერაცია  ჩაატარეთ Iteretor-ითა და ობიექტური for-ით.

6. ArrayList-დან  მართკუთხედები გადააკოპირეთ ისეთ სიმრავლეში, რომ დაგვრჩეს მხოლოდ  უნიკალური მნიშვნელობის მართკუთხედები და თან სიმრავლე ავტომატურად  სორტირებული იყოს ზრდადობით. შედარება განისაზღვროს ბუნებრივი წესით  (პირველი პუნქტი).

7. შექმენით ისეთი სიმრავლე, სადაც შენახული იქნება  მხოლოდ უნიკალური მართკუთხედები და ავტომატურად სორტირებული იქნება  კლებადობით. შედარების კრიტერიუმად აიღეთ მე-3 პუნქტში არსებული  პერიმეტრების შედარება.

8. შექმნით ისეთი მართკუთხედების სიმრავლეც,  რომელიც ავტომატურად არ დაასორტირებს მის ელემენტებს, მაგრამ დაიცავს მაინც  უნიკალურობას. შედარება მოახდინეთ პირველ პუნქტში აღწერილი მეთოდით: ანუ  თუ ერთი მართკუთხედის სიგრძე უდრის მეორე მართკუთხედის სიგრძეს და ერთი  მართკუთხედის სიგანე უდრის მეორე მართკუთხედის სიგანეს, მხოლოდ მაშინ  ჩაითვალოს ტოლად. წინააღმდეგ შემთხვევაში მართკუთხედები განსხვავდებიან.

9.  შეეცადეთ, რომ მართკუთხედის კლასში equals-ის გამოძახება მოხდეს რაც  შეილება ცოტაჯერ, მაგრამ ერთნაირ მართკუთხედებს განსხვავებული hashCode-ები  არ ჰქონდეს.

10. შექმენით Map, რომლის გასაღებიც იქნება მართკუთხედის  ტიპის ობიექტი, ხოლო მნიშვნელობა რაიმე სტრიქონი. Map უნდა იყოს  გასაღებებით დასორტირებული ზრდადობით პირველ პუნქტში აღწერილი ბუნებრივი  წესით. Map-ში შეეაცდეთ ჩაწეროთ ახალი ელემენტი არსებული გასაღებით, ისე  რომ ამ გასაღების მიმდინარე მნიშვნელობა არ დაიკარგოს და სადმე შეინახოთ.  ასევე ამოშალოთ ელემენტი გასაღებით ისე, რომ ამ ელემენტის მნიშვნელობა  სადმე შეინახოთ.

11. შექმენით Map, რომლის გასაღებიც იქნება  მართკუთხედის ტიპის ობიექტი, ხოლო მნიშვნელობა რაიმე მთელი რიცხვი. Map-ში  შედარების წესი განისაზღვროს მე-8 პუნქტში დაწერილი მეთოდით. Map-ზე  ჩაატარეთ 4 სხვადასხვა სახის იტერაცია: პირველს დააბეჭდინეთ მხოლოდ Map-ის  გასაღებები, მეორეს მხოლოდ Map-ის მნიშვნელობები, მესამეს ორივე ორივე  ერთად while და Iterator-ით და მეოთხესაც ორივე ერთად for და Map.Entry-ით.
